<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale: 1.0, user-scalable=no">
  <title>SolarBoard V1.1 – SolarBoard do VTriP Official (Nox/CNV) tạo ra</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
        integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Roboto', sans-serif;
      background: #f9f9f9;
    }
    :root {
      --primary-color: #6363DF;
      --toolbar-bg: #ffffff;
      --background-color: #f9f9f9;
      --button-bg: #ffffff;
      --button-hover-bg: #f0f0f0;
      --border-color: #ddd;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    #toolbar {
      position: fixed;
      top: 0;
      left: 0;
      width: 80px;
      height: 100vh;
      background: var(--toolbar-bg);
      padding: 20px 10px;
      padding-bottom: calc(20px + var(--safe-bottom));
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 100;
    }
    #toolbar button {
      width: 50px;
      height: 50px;
      border: none;
      border-radius: 12px;
      background: var(--button-bg);
      margin-bottom: 15px;
      color: #555;
      font-size: 1.5em;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    #toolbar button:hover {
      background: var(--button-hover-bg);
      color: var(--primary-color);
    }
    #toolbar button.active {
      background: var(--primary-color);
      color: #fff;
    }
    #options-button {
      margin-top: auto;
    }
    #canvas-container {
      position: absolute;
      top: 0;
      left: 80px;
      width: calc(100vw - 80px);
      height: 100vh;
      background: var(--background-color);
      cursor: grab;
      touch-action: none;
    }
    #canvas-container.panning {
      cursor: grabbing;
    }
    #canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
      will-change: transform;
    }
    #watermark-text {
      position: fixed;
      top: 10px;
      left: 90px;
      font-size: 12px;
      color: rgba(0,0,0,0.2);
      pointer-events: none;
      z-index: 99;
    }
    .pen-settings-menu {
      position: fixed;
      top: 100px;
      left: 90px;
      width: 280px;
      background: #fff;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      padding: 15px;
      z-index: 200;
      border-radius: 8px;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    .pen-settings-menu.hidden {
      transform: translateX(-20px);
      opacity: 0;
      pointer-events: none;
    }
    .pen-settings-menu .tabs {
      display: flex;
      border-bottom: 2px solid #eee;
      margin-bottom: 15px;
    }
    .pen-settings-menu .tabs button {
      flex: 1;
      padding: 12px 10px;
      background: transparent;
      border: none;
      font-size: 1em;
      color: #888;
      cursor: pointer;
      transition: color 0.3s, font-weight 0.3s;
      border-radius: 6px 6px 0 0;
    }
    .pen-settings-menu .tabs button.active {
      color: var(--primary-color);
      font-weight: bold;
      border-bottom: 3px solid var(--primary-color);
    }
    .pen-settings-menu .tab-content {
      padding-top: 15px;
    }
    .pen-settings-menu .tab-content:not(.active) {
      display: none;
    }
    .pen-settings-menu .colors-list,
    .pen-settings-menu .sizes-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
    }
    .pen-settings-menu .color-option {
      border: none;
      background: none;
      cursor: pointer;
      font-size: 1.4em;
      opacity: 0.8;
      transition: opacity 0.2s;
    }
    .pen-settings-menu .color-option:hover {
      opacity: 1;
    }
    #options-menu {
      position: fixed;
      bottom: calc(20px + var(--safe-bottom));
      left: 50%;
      transform: translateX(-50%);
      width: 250px;
      max-width: 90%;
      background: #fff;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      padding: 15px;
      z-index: 200;
      border-radius: 8px;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    #options-menu.hidden {
      transform: translateY(20px) translateX(-50%);
      opacity: 0;
      pointer-events: none;
    }
    .options-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      text-align: center;
    }
    .option-item {
      background: var(--button-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .option-item:hover {
      background: var(--button-hover-bg);
    }
    .option-item.active {
      background: var(--primary-color);
      color: #fff;
    }
    .option-item.active i,
    .option-item.active span {
      color: #fff;
    }
    .option-item i {
      font-size: 1.8em;
      margin-bottom: 5px;
    }
    .option-item span {
      font-size: 0.85em;
      color: #555;
    }
    .size-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      justify-items: center;
    }
    .size-option {
      width: 35px;
      height: 35px;
      border: 1px solid var(--border-color);
      border-radius: 50%;
      background: rgba(0,0,0,1);
      transition: transform 0.2s ease;
      cursor: pointer;
      opacity: 0.7;
    }
    .size-option:hover {
      opacity: 1;
    }
    .size-option.active {
      border: 2px solid var(--primary-color);
      transform: scale(1.1);
      opacity: 1;
    }
    #update-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 300;
    }
    #update-modal .modal-content {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      max-width: 90%;
    }
    #update-modal .modal-content h2 {
      margin: 0 0 10px;
      color: var(--primary-color);
    }
    #update-modal .modal-content p {
      margin: 0 0 20px;
      color: #333;
    }
    #update-modal .modal-content button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background: var(--primary-color);
      color: #fff;
      font-size: 1em;
      cursor: pointer;
      transition: background 0.2s;
    }
    #update-modal .modal-content button:hover {
      background: #5050c7;
    }
    @media (max-width: 768px) {
      #toolbar {
        width: 60px;
        padding: 10px;
      }
      #toolbar button {
        width: 40px;
        height: 40px;
        font-size: 1.2em;
      }
      #canvas-container {
        left: 60px;
        width: calc(100vw - 60px);
      }
      #watermark-text {
        left: 70px;
      }
      .pen-settings-menu, #options-menu {
        left: 50%;
        transform: translateX(-50%);
        width: 240px;
      }
    }
    .slider-container {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
    }
    .slider-container label {
      margin-right: 10px;
      font-size: 0.95em;
      color: #555;
    }
    .slider {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 10px;
      background: #ddd;
      border-radius: 6px;
      outline: none;
      -webkit-transition: .2s;
      transition: opacity .2s;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: var(--primary-color);
      cursor: pointer;
      border-radius: 50%;
      border: none;
      box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
    }
    .slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: var(--primary-color);
      cursor: pointer;
      border-radius: 50%;
      border: none;
      box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
    }
    #board-404 {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: var(--background-color);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 500;
      flex-direction: column;
      text-align: center;
      padding: 20px;
    }
    #board-404 h2 {
      font-size: 2em;
      color: #e74c3c;
      margin-bottom: 10px;
    }
    #board-404 p {
      font-size: 1.1em;
      color: #777;
    }
  </style>
</head>
<body>
  <div id="update-modal">
    <div class="modal-content">
      <h2>SolarBoard V1.1</h2>
      <p>Bản cập nhật của SolarBoard do VTriP Official (Nox/CNV) tạo ra.<br>
      Hiện tại, SolarBoard chưa có chế độ online.</p>
      <button id="close-update">Đóng</button>
    </div>
  </div>
  <div id="toolbar">
    <button id="undo-button" title="Undo"><i class="fas fa-undo"></i></button>
    <button id="redo-button" title="Redo"><i class="fas fa-redo"></i></button>
    <button id="pen-button" class="active" title="Pen"><i class="fas fa-pen"></i></button>
    <button id="eraser-button" title="Eraser"><i class="fas fa-eraser"></i></button>
    <button id="clear-button" title="Clear"><i class="fas fa-trash"></i></button>
    <button id="download-button" title="Download JPG"><i class="fas fa-download"></i></button>
    <button id="options-button" title="Options"><i class="fas fa-cog"></i></button>
  </div>
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
  </div>
  <div id="watermark-text">@VTriP Official - SolarBoard 1.0 Beta</div>
  <div id="pen-settings-menu" class="pen-settings-menu hidden">
    <div class="tabs">
      <button id="tab-base" class="tab active" data-target="content-base"><i class="fas fa-pen"></i> Base</button>
      <button id="tab-size" class="tab" data-target="content-size"><i class="fas fa-circle"></i> Size</button>
      <button id="tab-stabilization" class="tab" data-target="content-stabilization"><i class="fas fa-hand-sparkles"></i> Stabilization</button>
    </div>
    <div id="content-base" class="tab-content active">
      <div class="colors-list">
        <button class="color-option" data-color="#000000" title="Black">
          <i class="fas fa-pen" style="color:#000000"></i>
        </button>
        <button class="color-option" data-color="#2761A3" title="Blue">
          <i class="fas fa-pen" style="color:#2761A3"></i>
        </button>
        <button class="color-option" data-color="#44BDF2" title="Aqua">
          <i class="fas fa-pen" style="color:#44BDF2"></i>
        </button>
        <button class="color-option" data-color="#C1086C" title="Red">
          <i class="fas fa-pen" style="color:#C1086C"></i>
        </button>
        <button class="color-option" data-color="#98BA13" title="Green">
          <i class="fas fa-pen" style="color:#98BA13"></i>
        </button>
        <button class="color-option" data-color="#A791E3" title="Purple">
          <i class="fas fa-pen" style="color:#A791E3"></i>
        </button>
        <button class="color-option" data-color="#E5B52F" title="Yellow">
          <i class="fas fa-pen" style="color:#E5B52F"></i>
        </button>
      </div>
    </div>
    <div id="content-size" class="tab-content">
      <div class="sizes-list">
        <div class="size-grid"></div>
      </div>
    </div>
    <div id="content-stabilization" class="tab-content">
      <div class="slider-container">
        <label for="stabilization-slider">Level:</label>
        <input type="range" min="1" max="10" value="1" class="slider" id="stabilization-slider">
        <span id="stabilization-value">1</span>
      </div>
    </div>
  </div>
  <div id="options-menu" class="pen-settings-menu hidden">
    <div class="options-grid">
      <div class="option-item" id="option-svgmode">
        <i class="fas fa-adjust"></i>
        <span>SvgMode</span>
      </div>
      <div class="option-item" id="option-fullscreen">
        <i class="fas fa-expand"></i>
        <span>Full Screen</span>
      </div>
      <div class="option-item" id="option-settings">
        <i class="fas fa-cog"></i>
        <span>Settings</span>
      </div>
    </div>
  </div>
  <div id="board-404" class="hidden">
    <h2>404 Board Not Found</h2>
    <p>The SolarBoard server ID you entered is invalid or does not exist.</p>
  </div>
<script>
    document.getElementById('close-update').addEventListener('click', function() {
      document.getElementById('update-modal').style.display = 'none';
    });
    const dpi = window.devicePixelRatio || 1;
    let svgMode = false;
    let guideTarget = null;
    let confirmedPoint = null;
    let svgAnimRequest = null;
    const updateSpeed = 0.1;
    const minGap = 10;
    let drawGridOnScreen = true;
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const canvasContainer = document.getElementById('canvas-container');
    const penButton = document.getElementById('pen-button');
    const eraserButton = document.getElementById('eraser-button');
    const clearButton = document.getElementById('clear-button');
    const undoButton = document.getElementById('undo-button');
    const redoButton = document.getElementById('redo-button');
    const optionsButton = document.getElementById('options-button');
    const optionsMenu = document.getElementById('options-menu');
    const optionSvgMode = document.getElementById('option-svgmode');
    const optionFullscreen = document.getElementById('option-fullscreen');
    const optionSettings = document.getElementById('option-settings');
    const downloadButton = document.getElementById('download-button');
    const watermarkTextElement = document.getElementById('watermark-text');
    const stabilizationSlider = document.getElementById('stabilization-slider');
    const stabilizationValueDisplay = document.getElementById('stabilization-value');
    const tabButtons = document.querySelectorAll('.pen-settings-menu .tabs .tab');
    const tabContents = document.querySelectorAll('.pen-settings-menu .tab-content');
    const penSettingsMenu = document.getElementById('pen-settings-menu');
    const board404 = document.getElementById('board-404');
    let scale = 1, translateX = 0, translateY = 0;
    let strokes = [];
    let currentStroke = null;
    let isDrawing = false;
    let isPanning = false;
    let currentTool = 'pen';
    let penColor = 'black';
    let penSize = 2;
    let eraserSize = 5;
    let lastX, lastY;
    let actions = [], redoActions = [];
    let penStabilizationLevel = 1;
    let lastStabilizedPoint = null;
    let serverId = null;
    let userId = getCookie('solarboard_user_id') || generateUserId();

    function getCookie(name) {
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${name}=`);
      if (parts.length === 2) return parts.pop().split(';').shift();
      return null;
    }

    function setCookie(name, value, days) {
      let expires = "";
      if (days) {
        const date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = "; expires=" + date.toUTCString();
      }
      document.cookie = name + "=" + (value || "") + expires + "; path=/";
    }

    function generateUserId() {
      const id = 'user_' + Math.random().toString(36).substring(2, 15);
      setCookie('solarboard_user_id', id, 365);
      return id;
    }

    function getParameterByName(name, url = window.location.href) {
      name = name.replace(/[]/g, '\\$&');
      const regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
          results = regex.exec(url);
      if (!results) return null;
      if (!results[2]) return '';
      return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }

    serverId = getParameterByName('server');

    function resizeCanvas() {
      const rect = canvasContainer.getBoundingClientRect();
      canvas.width = rect.width * dpi;
      canvas.height = rect.height * dpi;
      canvas.style.width = rect.width + "px";
      canvas.style.height = rect.height + "px";
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      draw();
    }
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', resizeCanvas);
    resizeCanvas();

    function filterPoints(points, minDist = 3) {
      if (!points || points.length === 0) return points;
      const filtered = [points[0]];
      for (let i = 1; i < points.length; i++) {
        const dx = points[i].x - filtered[filtered.length - 1].x;
        const dy = points[i].y - filtered[filtered.length - 1].y;
        if (Math.hypot(dx, dy) >= minDist) {
          filtered.push(points[i]);
        }
      }
      return filtered;
    }

    function drawSmoothStrokePoints(points, strokeColor, strokeWidth) {
      const filtered = filterPoints(points, 3);
      if (!filtered || filtered.length < 2) return;
      ctx.beginPath();
      ctx.moveTo(filtered[0].x, filtered[0].y);
      for (let i = 0; i < filtered.length - 1; i++) {
        const p0 = i === 0 ? filtered[i] : filtered[i - 1];
        const p1 = filtered[i];
        const p2 = filtered[i + 1];
        const p3 = (i + 2 < filtered.length) ? filtered[i + 2] : p2;
        const cp1x = p1.x + (p2.x - p0.x) / 6;
        const cp1y = p1.y + (p2.y - p0.y) / 6;
        const cp2x = p2.x - (p3.x - p1.x) / 6;
        const cp2y = p2.y - (p3.y - p1.y) / 6;
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
      }
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.scale(dpi, dpi);
      ctx.translate(translateX, translateY);
      ctx.scale(scale, scale);
      if (drawGridOnScreen) {
        drawGrid();
      }
      // Sửa lỗi: kiểm tra stroke.stroke thay vì stroke.points
      strokes.forEach(stroke => {
        if (!stroke || !stroke.stroke || stroke.stroke.points.length < 2) return;
        drawSmoothStrokePoints(stroke.stroke.points, stroke.stroke.color, stroke.stroke.size);
      });
      if (svgMode && isDrawing && confirmedPoint && guideTarget) {
        ctx.save();
        ctx.strokeStyle = "rgba(255,0,0,0.2)";
        ctx.lineWidth = penSize;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(confirmedPoint.x, confirmedPoint.y);
        ctx.lineTo(guideTarget.x, guideTarget.y);
        ctx.stroke();
        ctx.restore();
      }
      ctx.restore();
    }

    function drawGrid() {
      const gridSpacing = 50;
      const left = -translateX / scale;
      const top = -translateY / scale;
      const right = left + canvasContainer.clientWidth / scale;
      const bottom = top + canvasContainer.clientHeight / scale;
      ctx.beginPath();
      for (let x = Math.floor(left / gridSpacing) * gridSpacing; x < right; x += gridSpacing) {
        ctx.moveTo(x, top);
        ctx.lineTo(x, bottom);
      }
      for (let y = Math.floor(top / gridSpacing) * gridSpacing; y < bottom; y += gridSpacing) {
        ctx.moveTo(left, y);
        ctx.lineTo(right, y);
      }
      ctx.strokeStyle = "rgba(200, 200, 200, 0.5)";
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    function getVirtualCoords(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (clientX - rect.left - translateX) / scale,
        y: (clientY - rect.top - translateY) / scale
      };
    }

    function updateSvgMode() {
      if (!isDrawing || !svgMode || !guideTarget || !confirmedPoint) {
        cancelAnimationFrame(svgAnimRequest);
        svgAnimRequest = null;
        return;
      }
      const dx = guideTarget.x - confirmedPoint.x;
      const dy = guideTarget.y - confirmedPoint.y;
      const dist = Math.hypot(dx, dy);
      if (dist > minGap) {
        confirmedPoint.x += dx * updateSpeed;
        confirmedPoint.y += dy * updateSpeed;
        currentStroke.stroke.points.push({ x: confirmedPoint.x, y: confirmedPoint.y });
      }
      draw();
      svgAnimRequest = requestAnimationFrame(updateSvgMode);
    }

    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', handleDraw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    canvasContainer.addEventListener('touchstart', startDrawing, { passive: false });
    canvasContainer.addEventListener('touchmove', handleDraw, { passive: false });
    canvasContainer.addEventListener('touchend', stopDrawing);
    canvasContainer.addEventListener('touchcancel', stopDrawing);

    function startDrawing(e) {
      if (isPanning || (e.touches && e.touches.length > 1)) return;
      const point = getVirtualCoords(e.clientX ?? e.touches[0].clientX, e.clientY ?? e.touches[0].clientY);
      if (currentTool === 'eraser') {
        eraseStrokeAt(point);
        isDrawing = true;
        return;
      }
      isDrawing = true;
      lastX = point.x;
      lastY = point.y;
      currentStroke = { userId: userId, stroke: { tool: currentTool, points: [point], color: penColor, size: penSize } };
      strokes.push(currentStroke);
      sendStroke(currentStroke);
      lastStabilizedPoint = point;
      if (svgMode) {
        guideTarget = { x: point.x, y: point.y };
        confirmedPoint = { x: point.x, y: point.y };
        if (!svgAnimRequest) svgAnimRequest = requestAnimationFrame(updateSvgMode);
      }
    }

    function handleDraw(e) {
      if (!isDrawing || isPanning) return;
      e.preventDefault();
      let point = getVirtualCoords(e.clientX ?? e.touches[0].clientX, e.clientY ?? e.touches[0].clientY);
      if (!currentStroke) return;
      if (currentTool === 'pen' && penStabilizationLevel > 1) {
        const stabilizationFactor = 1 / penStabilizationLevel;
        point = {
          x: lastStabilizedPoint.x * (1 - stabilizationFactor) + point.x * stabilizationFactor,
          y: lastStabilizedPoint.y * (1 - stabilizationFactor) + point.y * stabilizationFactor
        };
        lastStabilizedPoint = point;
      }
      if (currentTool === 'eraser') {
        eraseStrokeAt(point);
      } else {
        if (svgMode) {
          guideTarget = { x: point.x, y: point.y };
        } else {
          currentStroke.stroke.points.push(point);
          sendStroke(currentStroke);
        }
      }
      lastX = point.x;
      lastY = point.y;
      draw();
    }

    function stopDrawing() {
      if (isDrawing && currentStroke && currentStroke.stroke.points.length > 1) {
        if (currentTool !== 'eraser' && svgMode) {
          const finishInterval = setInterval(() => {
            if (!guideTarget || !confirmedPoint) {
              clearInterval(finishInterval);
              return;
            }
            const dx = guideTarget.x - confirmedPoint.x;
            const dy = guideTarget.y - confirmedPoint.y;
            const dist = Math.hypot(dx, dy);
            if (dist > minGap) {
              confirmedPoint.x += dx * updateSpeed;
              currentStroke.stroke.points.push({ x: confirmedPoint.x, y: confirmedPoint.y });
              draw();
            } else {
              clearInterval(finishInterval);
            }
          }, 16);
        }
        if (currentTool !== 'eraser') {
          actions.push({ type: 'draw', stroke: currentStroke });
          redoActions = [];
        }
      }
      isDrawing = false;
      currentStroke = null;
      guideTarget = null;
      confirmedPoint = null;
      cancelAnimationFrame(svgAnimRequest);
      svgAnimRequest = null;
      isPanning = false;
      canvasContainer.classList.remove('panning');
      draw();
      lastStabilizedPoint = null;
    }

    function eraseStrokeAt(virtualPoint) {
      const tolerance = 25;
      for (let i = strokes.length - 1; i >= 0; i--) {
        const strokeData = strokes[i];
        if (!strokeData || !strokeData.stroke.points) continue;
        for (let j = 0; j < strokeData.stroke.points.length; j++) {
          const pt = strokeData.stroke.points[j];
          const d = Math.hypot(virtualPoint.x - pt.x, virtualPoint.y - pt.y);
          if (d < tolerance) {
            strokes.splice(i, 1);
            actions.push({ type: 'erase', stroke: strokeData });
            redoActions = [];
            draw();
            return;
          }
        }
      }
    }

    optionFullscreen.addEventListener('click', () => {
      if (!document.fullscreenElement) {
        if (canvasContainer.requestFullscreen) {
          canvasContainer.requestFullscreen();
        } else if (canvasContainer.mozRequestFullScreen) {
          canvasContainer.mozRequestFullScreen();
        } else if (canvasContainer.webkitRequestFullscreen) {
          canvasContainer.webkitRequestFullscreen();
        } else if (canvasContainer.msRequestFullscreen) {
          canvasContainer.msRequestFullscreen();
        }
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
      }
    });

    optionSvgMode.addEventListener('click', function() {
      svgMode = !svgMode;
      this.classList.toggle('active');
    });

    optionSettings.addEventListener('click', () => {
      alert("Mở giao diện Settings nâng cao.");
    });

    optionsButton.addEventListener('click', () => {
      optionsMenu.classList.toggle('hidden');
    });

    penButton.addEventListener('click', () => {
      const menu = document.getElementById('pen-settings-menu');
      if (currentTool === 'pen') {
        menu.classList.toggle('hidden');
      }
      currentTool = 'pen';
      penButton.classList.add('active');
      eraserButton.classList.remove('active');
      canvasContainer.style.cursor = 'crosshair';
      canvas.style.cursor = 'crosshair';
      canvasContainer.classList.remove('panning');
    });

    eraserButton.addEventListener('click', () => {
      if (isDrawing) { stopDrawing(); }
      currentTool = 'eraser';
      eraserButton.classList.add('active');
      penButton.classList.remove('active');
      canvasContainer.style.cursor = 'default';
      canvas.style.cursor = 'default';
      canvasContainer.classList.remove('panning');
      document.getElementById('pen-settings-menu').classList.add('hidden');
    });

    clearButton.addEventListener('click', () => {
      strokes = [];
      draw();
    });

    undoButton.addEventListener('click', () => {
      if (actions.length === 0) return;
      const lastAction = actions.pop();
      if (lastAction.type === 'draw') {
        const index = strokes.findIndex(s => s === lastAction.stroke);
        if (index !== -1) strokes.splice(index, 1);
      } else if (lastAction.type === 'erase') {
        strokes.push(lastAction.stroke);
      }
      redoActions.push(lastAction);
      draw();
    });

    redoButton.addEventListener('click', () => {
      if (redoActions.length === 0) return;
      const action = redoActions.pop();
      if (action.type === 'draw') {
        strokes.push(action.stroke);
      } else if (action.type === 'erase') {
        const index = strokes.findIndex(s => s === action.stroke);
        if (index !== -1) strokes.splice(index, 1);
      }
      actions.push(action);
      draw();
    });

    tabButtons.forEach(button => {
      button.addEventListener('click', function() {
        const targetContentId = this.dataset.target;
        const isActive = this.classList.contains('active');
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabContents.forEach(content => content.classList.remove('active'));
        if(isActive) {
          penSettingsMenu.classList.add('hidden');
        } else {
          penSettingsMenu.classList.remove('hidden');
          this.classList.add('active');
          document.getElementById(targetContentId).classList.add('active');
        }
      });
    });

    document.querySelectorAll('.color-option').forEach(button => {
      button.addEventListener('click', function() {
        penColor = this.getAttribute('data-color');
        penButton.querySelector('i').style.color = penColor;
      });
    });

    function generateSizeGrid() {
      const sizeGrid = document.querySelector('.size-grid');
      sizeGrid.innerHTML = '';
      const categorySizes = [2, 4, 6, 8, 10];
      const numRows = 5;
      const categoryNames = ["Finest", "Fine", "Medium", "Large", "Largest"];
      for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < categorySizes.length; col++) {
          const diameter = categorySizes[col];
          const opacity = 1 - (row * 0.6 / (numRows - 1));
          const btn = document.createElement('button');
          btn.classList.add('size-option');
          btn.style.width = diameter * 3 + 'px';
          btn.style.height = diameter * 3 + 'px';
          btn.style.backgroundColor = `rgba(0,0,0,${opacity})`;
          btn.dataset.size = categorySizes[col];
          btn.title = categoryNames[col] + " " + (row + 1);
          btn.addEventListener('click', function() {
            penSize = Number(this.dataset.size);
            document.querySelectorAll('.size-option').forEach(el => el.classList.remove('active'));
            this.classList.add('active');
          });
          sizeGrid.appendChild(btn);
        }
      }
    }
    generateSizeGrid();

    function downloadCanvasAsJPG() {
      drawGridOnScreen = false;
      draw();
      ctx.save();
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "rgba(0, 0, 0, 0.7)";
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(0, 0, canvas.width, canvas.height);
      ctx.setLineDash([]);
      ctx.scale(dpi, dpi);
      ctx.translate(translateX, translateY);
      ctx.scale(scale, scale);
      strokes.forEach(stroke => {
        if (!stroke || !stroke.stroke || stroke.stroke.points.length < 2) return;
        drawSmoothStrokePoints(stroke.stroke.points, stroke.stroke.color, stroke.stroke.size);
      });
      const watermarkText = watermarkTextElement.textContent;
      ctx.font = "16px Roboto";
      ctx.fillStyle = "rgba(0,0,0,0.3)";
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText(watermarkText, 10, 10);
      const imageDataURL = canvas.toDataURL('image/jpeg', 0.98);
      const downloadLink = document.createElement('a');
      downloadLink.href = imageDataURL;
      downloadLink.download = 'solarboard_drawing.jpg';
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
      ctx.restore();
      drawGridOnScreen = true;
      draw();
    }

    downloadButton.addEventListener('click', downloadCanvasAsJPG);
    stabilizationSlider.addEventListener('input', function() {
      penStabilizationLevel = parseInt(this.value);
      stabilizationValueDisplay.textContent = this.value;
    });

    async function fetchBoardData() {
        if (!serverId) {
            board404.classList.remove('hidden');
            return;
        }
        board404.classList.add('hidden');
        const apiURL = `https://api.github.com/repos/TDAIP/18im/contents/server.api?ref=main`;
        const githubToken = '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';

        try {
            const response = await fetch(apiURL, {
                headers: {
                    'Authorization': `token ${githubToken}`,
                    'Accept': 'application/vnd.github.v3.raw',
                }
            });

            if (!response.ok) {
                console.error('Failed to fetch server API data:', response.status, response.statusText);
                return;
            }

            const rawContent = await response.text();
            const apiData = JSON.parse(rawContent);
            const server = apiData.servers.find(s => s.id === serverId);

            if (!server) {
                board404.classList.remove('hidden');
                return;
            }
            strokes = server.drawing.map(item => ({ ...item }));
            draw();

        } catch (error) {
            console.error('Error fetching or processing server data:', error);
        }
    }

    async function sendStroke(strokeData) {
        if (!serverId) return;

        const apiURL = `https://api.github.com/repos/TDAIP/18im/contents/server.api?ref=main`;
        const githubToken = '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';

        try {
            // Sử dụng header JSON để lấy thông tin sha
            const response = await fetch(apiURL, {
                headers: {
                    'Authorization': `token ${githubToken}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });

            if (!response.ok) {
                console.error('Failed to fetch server API data for update:', response.status, response.statusText);
                return;
            }
            const apiData = await response.json();
            // Giải mã nội dung file từ Base64 và parse JSON
            const decodedContent = atob(apiData.content);
            const fileData = JSON.parse(decodedContent);
            const serverIndex = fileData.servers.findIndex(s => s.id === serverId);

            if (serverIndex === -1) {
                console.error('Server ID not found in API for update.');
                return;
            }

            fileData.servers[serverIndex].drawing.push(strokeData);

            const updatedContent = JSON.stringify(fileData, null, 2);
            const contentBase64 = btoa(updatedContent);

            const commitResponse = await fetch(apiURL, {
                method: 'PUT',
                headers: {
                    'Authorization': `token ${githubToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: 'Update SolarBoard drawing data',
                    content: contentBase64,
                    sha: apiData.sha
                })
            });

            if (!commitResponse.ok) {
                console.error('Failed to commit updated API data:', commitResponse.status, commitResponse.statusText);
            }

        } catch (error) {
            console.error('Error sending stroke data to server:', error);
        }
    }

    fetchBoardData();
    setInterval(fetchBoardData, 3000);
  </script>
</body>
</html>
