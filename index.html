<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>SolarBoard - Web Vẽ Mobile (Vô Hạn & Tối Ưu)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Roboto', sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    :root {
      --primary-color: #6363DF;
      --secondary-color: #f39c12;
      --background-color: #f4f7f9;
      --toolbar-background: #fff;
      --text-color: #333;
      --icon-color: #555;
      --icon-hover-color: var(--primary-color);
      --icon-active-color: white;
      --button-background: #fff;
      --button-hover-background: #f0f0f0;
      --button-active-background: var(--primary-color);
      --border-color: #ddd;
    }

    /* CSS giữ nguyên */
    #toolbar {
      position: fixed;
      top: 0;
      left: 0;
      width: 80px;
      height: 100vh;
      background-color: var(--toolbar-background);
      padding: 20px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 100;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
    }
    #toolbar button {
      margin-bottom: 15px;
      padding: 12px;
      width: 50px;
      height: 50px;
      border-radius: 10px;
      border: none;
      background-color: var(--button-background);
      color: var(--icon-color);
      cursor: pointer;
      font-size: 1.5em;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background-color 0.2s ease, color: 0.2s ease;
    }
    #toolbar button:hover {
      background-color: var(--button-hover-background);
      color: var(--icon-hover-color);
    }
    #toolbar button.active {
      background-color: var(--button-active-background);
      color: var(--icon-active-color);
    }
    #canvas-container {
      position: absolute;
      top: 0;
      left: 80px;
      width: calc(100vw - 80px);
      height: 100vh;
      overflow: hidden;
      touch-action: none;
      background-color: var(--background-color);
      cursor: grab;
    }
    #canvas-container.panning {
      cursor: grabbing;
    }
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
    }
    #watermark-text {
      position: fixed;
      top: 10px;
      left: 90px;
      font-size: 12px;
      color: rgba(0, 0, 0, 0.2);
      pointer-events: none;
      z-index: 99;
    }
    @media (max-width: 768px) {
      #toolbar {
        width: 60px;
        padding: 10px;
      }
      #toolbar button {
        width: 40px;
        height: 40px;
        padding: 8px;
        font-size: 1.2em;
      }
      #canvas-container {
        left: 60px;
        width: calc(100vw - 60px);
      }
      #watermark-text {
        left: 70px;
      }
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="pen-button" class="active" title="Bút"><i class="fas fa-pen"></i></button>
    <button id="eraser-button" title="Tẩy nét vẽ"><i class="fas fa-eraser"></i></button>
    <button id="clear-button" title="Xóa bảng vẽ"><i class="fas fa-trash"></i></button>
  </div>
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
  </div>
  <div id="watermark-text">@VTriP Official - SolarBoard 1.0 Beta</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const canvasContainer = document.getElementById('canvas-container');

    let scale = 1, translateX = 0, translateY = 0;
    let strokes = [];
    let currentStroke = null;
    let isDrawing = false;
    let isPanning = false;
    let lastPanX = 0, lastPanY = 0;
    let currentTool = 'pen';
    let penColor = 'black';
    let penSize = 2;
    let eraserSize = 5;

    function resizeCanvas() {
      canvas.width = canvasContainer.offsetWidth;
      canvas.height = canvasContainer.offsetHeight;
      draw();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.setTransform(scale, 0, 0, scale, translateX, translateY);
      drawGrid();
      strokes.forEach(stroke => {
        if (stroke.points.length < 2) return;
        ctx.beginPath();
        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        // Vẽ đường cong Bezier
        for (let i = 1; i < stroke.points.length - 1; i++) {
          const midPoint = {
            x: (stroke.points[i].x + stroke.points[i + 1].x) / 2,
            y: (stroke.points[i].y + stroke.points[i + 1].y) / 2
          };
          ctx.quadraticCurveTo(
            stroke.points[i].x, stroke.points[i].y,
            midPoint.x, midPoint.y
          );
        }
        // Vẽ đoạn cuối từ điểm gần cuối đến điểm cuối
        ctx.lineTo(stroke.points[stroke.points.length - 1].x, stroke.points[stroke.points.length - 1].y);


        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round'; // Thêm lineJoin để các góc mượt hơn
        ctx.stroke();
      });
      ctx.restore();
    }

    function drawGrid() {
      const gridSpacing = 50;
      let left = -translateX / scale;
      let top = -translateY / scale;
      let right = left + canvas.width / scale;
      let bottom = top + canvas.height / scale;

      ctx.beginPath();
      for (let x = Math.floor(left / gridSpacing) * gridSpacing; x < right; x += gridSpacing) {
        ctx.moveTo(x, top);
        ctx.lineTo(x, bottom);
      }
      for (let y = Math.floor(top / gridSpacing) * gridSpacing; y < bottom; y += gridSpacing) {
        ctx.moveTo(left, y);
        ctx.lineTo(right, y);
      }
      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    function getVirtualCoords(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (clientX - rect.left - translateX) / scale,
        y: (clientY - rect.top - translateY) / scale
      };
    }

    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', handleDraw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);

    canvasContainer.addEventListener('touchstart', startDrawing, { passive: false });
    canvasContainer.addEventListener('touchmove', handleDraw, { passive: false });
    canvasContainer.addEventListener('touchend', stopDrawing);
    canvasContainer.addEventListener('touchcancel', stopDrawing);


    function startDrawing(e) {
      if (isPanning || (e.touches && e.touches.length > 1)) return;
      if (currentTool === 'eraser') return;

      isDrawing = true;
      const point = getVirtualCoords(e.clientX ?? e.touches[0].clientX, e.clientY ?? e.touches[0].clientY);
      lastX = point.x;
      lastY = point.y;
      currentStroke = { tool: currentTool, points: [point], color: penColor, size: penSize };
      strokes.push(currentStroke);
    }

    function handleDraw(e) {
      if (!isDrawing || isPanning) return;
      e.preventDefault();

      const point = getVirtualCoords(e.clientX ?? e.touches[0].clientX, e.clientY ?? e.touches[0].clientY);
      mouseX = point.x;
      mouseY = point.y;

      if (!currentStroke) return;

      currentStroke.points.push(point);

      ctx.save();
      ctx.setTransform(scale, 0, 0, scale, translateX, translateY);
      ctx.beginPath();
      const pts = currentStroke.points;
      if (pts.length > 2) { // Đảm bảo có đủ điểm để vẽ curve
        const lastMidPoint = {
            x: (pts[pts.length - 3].x + pts[pts.length - 2].x) / 2,
            y: (pts[pts.length - 3].y + pts[pts.length - 2].y) / 2
        };
        const controlPoint = pts[pts.length - 2];
        ctx.moveTo(lastMidPoint.x, lastMidPoint.y);
        ctx.quadraticCurveTo(
            controlPoint.x, controlPoint.y,
            point.x, mouseY // Điểm cuối là mouseX, mouseY hiện tại
        );


      } else if (pts.length === 2) {
          const last = pts[pts.length - 2];
          ctx.moveTo(last.x, last.y);
          ctx.lineTo(mouseX, mouseY);
      }


      ctx.strokeStyle = currentStroke.color;
      ctx.lineWidth = currentStroke.size;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();
      ctx.restore();

      lastX = mouseX;
      lastY = mouseY;
    }


    function stopDrawing() {
      isDrawing = false;
      currentStroke = null;
      isPanning = false;
      canvasContainer.classList.remove('panning');
      draw();
    }


    // Zoom và Pan (giữ nguyên từ code trước)
    let lastTouchDist = null;
    let lastTouchCenter = null;
    canvasContainer.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        lastTouchDist = getTouchDistance(e.touches[0], e.touches[1]);
        lastTouchCenter = getTouchCenter(e.touches[0], e.touches[1]);
        isPanning = true;
        canvasContainer.classList.add('panning');
        isDrawing = false;
      }
    }, { passive: false });

    canvasContainer.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        isDrawing = false;
        isPanning = true;
        const newDist = getTouchDistance(e.touches[0], e.touches[1]);
        const newCenter = getTouchCenter(e.touches[0], e.touches[1]);
        const zoomFactor = newDist / lastTouchDist;
        scale *= zoomFactor;
        translateX = newCenter.x - zoomFactor * (lastTouchCenter.x - translateX);
        translateY = newCenter.y - zoomFactor * (lastTouchCenter.y - translateY);
        lastTouchDist = newDist;
        lastTouchCenter = newCenter;
        draw();
      } else if (currentTool === 'eraser' && e.touches.length === 1) {
        e.preventDefault();
        const virtualPos = getVirtualCoords(e.touches[0].clientX, e.touches[0].clientY);
        eraseStrokeAt(virtualPos);
      }     else if (e.touches.length === 1 && currentTool !== 'eraser') {
        e.preventDefault();
        isDrawing = true;
        isPanning = false;
        handleDraw(e);
      }
    }, { passive: false });

    canvasContainer.addEventListener('touchend', (e) => {
      if (e.touches.length <= 1) {
        isDrawing = false;
        isPanning = false;
        canvasContainer.classList.remove('panning');
        draw();
      }
    });
    canvasContainer.addEventListener('touchcancel', (e) => {
        isDrawing = false;
        isPanning = false;
        canvasContainer.classList.remove('panning');
    });

    function getTouchDistance(t1, t2) {
      const dx = t2.clientX - t1.clientX;
      const dy = t2.clientY - t1.clientY;
      return Math.hypot(dx, dy);
    }
    function getTouchCenter(t1, t2) {
      return {
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      };
    }

    // Hàm xóa nét vẽ tại vị trí ảo (giữ nguyên từ code trước)
    function eraseStrokeAt(virtualPoint) {
      for (let i = strokes.length - 1; i >= 0; i--) {
        const stroke = strokes[i];
        for (let j = 0; j < stroke.points.length - 1; j++) {
          const p1 = stroke.points[j];
          const p2 = stroke.points[j+1];
          if (isPointOnLine(virtualPoint, p1, p2, eraserSize / scale )) {
            strokes.splice(i, 1);
            draw();
            return;
          }
        }
      }
    }

    function isPointOnLine(p, p1, p2, tolerance) {
      const d = Math.abs((p2.y - p1.y) * p.x - (p2.x - p1.x) * p.y + p2.x * p1.y - p2.y * p1.x) / Math.hypot(p2.x - p1.x, p2.y - p1.y);
      if (d <= tolerance) {
        const dotProduct = (p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y);
        const squaredLength = Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2);
        if (dotProduct >= 0 && dotProduct <= squaredLength) {
          return true;
        }
      }
      return false;
    }


    // ------------------ Xử lý các nút công cụ ------------------
    const penButton = document.getElementById('pen-button');
    const eraserButton = document.getElementById('eraser-button');
    const clearButton = document.getElementById('clear-button');

    penButton.addEventListener('click', () => {
      currentTool = 'pen';
      penButton.classList.add('active');
      eraserButton.classList.remove('active');
      canvasContainer.style.cursor = 'crosshair';
      canvas.style.cursor = 'crosshair';
      canvasContainer.classList.remove('panning');
    });
    eraserButton.addEventListener('click', () => {
      currentTool = 'eraser';
      eraserButton.classList.add('active');
      penButton.classList.remove('active');
      canvasContainer.style.cursor = 'default';
      canvas.style.cursor = 'default';
      canvasContainer.classList.remove('panning');
    });
    clearButton.addEventListener('click', () => {
      strokes = [];
      draw();
    });
  </script>
</body>
</html>
